// SPDX-License-Identifier: MIT
pragma solidity ^0.8.27;

import {FHE, euint32, ebool, externalEuint32} from "@fhevm/solidity/lib/FHE.sol";
import {SepoliaConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

/// @title ConfidentialBomb
/// @notice A minimal confidential "Minesweeper"-style game using Zama FHEVM.
/// @dev The contract only stores encrypted tiles. Every action (create, pick, reveal)
///      works directly on ciphertext, so the board is never revealed on-chain.
contract ConfidentialBomb is SepoliaConfig {
    // ---------------- Types & Storage ----------------

    enum State { Active, Ended }

    struct Game {
        address player;
        uint8 boardSize;         // length of the 1D board (e.g., 9 = 3x3)
        euint32[] board;         // encrypted tiles: 0 = safe, 1 = bomb
        bytes32 commitHash;      // commit = keccak256(seed, player, boardSize)
        uint32 openedCount;      // how many tiles were opened (non-sensitive info)
        State state;
    }

    uint256 public gameCounter;
    mapping(uint256 => Game) public games;

    // A simple bitmap to mark which tiles are already opened (supports up to 256 tiles)
    mapping(uint256 => uint256) private _openedMask;

    // ---------------- Events ----------------

    event GameCreated(uint256 indexed gameId, address indexed player, uint8 boardSize, bytes32 commitHash);
    /// Emits an encrypted boolean → you can’t tell if it’s a bomb without decryption
    event TilePicked(uint256 indexed gameId, uint8 index, ebool isBomb, uint32 openedCount);
    event GameEnded(uint256 indexed gameId);
    event SeedRevealed(uint256 indexed gameId, uint256 seed);
    /// Optional: allows publishing the plaintext board for off-chain verification
    event GameRevealed(uint256 indexed gameId, uint32[] plainBoard);

    // ---------------- Create ----------------

    /// @notice Create a new game with an encrypted board
    /// @param encryptedTiles  list of encrypted tile handles from the SDK
    /// @param proof           batch proof generated by the SDK
    /// @param commitHash      commit = keccak256(seed, msg.sender, boardSize)
    /// @param boardSize       number of tiles in the board (must match encryptedTiles.length)
    function createGame(
        externalEuint32[] calldata encryptedTiles,
        bytes calldata proof,
        bytes32 commitHash,
        uint8 boardSize
    ) external returns (uint256 gameId) {
        require(boardSize > 0, "Invalid board size");
        require(encryptedTiles.length == boardSize, "Board size mismatch");
        require(commitHash != bytes32(0), "Empty commit");

        euint32[] memory board = new euint32[](boardSize);
        for (uint256 i = 0; i < boardSize; i++) {
            // Import each encrypted tile from off-chain
            board[i] = FHE.fromExternal(encryptedTiles[i], proof);
            // Allow this contract to use the ciphertext in computations
            FHE.allowThis(board[i]);
        }

        gameId = ++gameCounter;
        games[gameId] = Game({
            player: msg.sender,
            boardSize: boardSize,
            board: board,
            commitHash: commitHash,
            openedCount: 0,
            state: State.Active
        });

        _openedMask[gameId] = 0;

        emit GameCreated(gameId, msg.sender, boardSize, commitHash);
    }

    // ---------------- Play ----------------

    /// @notice Open a tile. Emits `isBomb` as an encrypted boolean.
    function pickTile(uint256 gameId, uint8 index) external {
        Game storage g = games[gameId];
        require(g.state == State.Active, "Game ended");
        require(msg.sender == g.player, "Not your game");
        require(index < g.boardSize, "Bad index");

        uint256 mask = _openedMask[gameId];
        uint256 bit = 1 << index;
        require(mask & bit == 0, "Already opened");
        _openedMask[gameId] = mask | bit;

        euint32 tile = g.board[index];
        ebool isBomb = FHE.eq(tile, FHE.asEuint32(1));

        g.openedCount += 1;

        emit TilePicked(gameId, index, isBomb, g.openedCount);
    }

    /// @notice End a game (e.g., after hitting a bomb or quitting).
    function endGame(uint256 gameId) external {
        Game storage g = games[gameId];
        require(msg.sender == g.player, "Not your game");
        require(g.state == State.Active, "Already ended");
        g.state = State.Ended;
        emit GameEnded(gameId);
    }

    // ---------------- Provably-Fair Reveal ----------------

    /// @notice Reveal the original seed to prove the commit was valid.
    function revealSeed(uint256 gameId, uint256 seed) external {
        Game storage g = games[gameId];
        require(msg.sender == g.player, "Not your game");
        require(g.state == State.Ended, "End first");

        bytes32 expected = keccak256(abi.encode(seed, g.player, g.boardSize));
        require(expected == g.commitHash, "Commit mismatch");

        emit SeedRevealed(gameId, seed);
    }

    /// @notice (Optional) Reveal the plaintext board for off-chain tools to re-check.
    function revealGame(uint256 gameId, uint32[] calldata plainBoard) external {
        Game storage g = games[gameId];
        require(msg.sender == g.player, "Not your game");
        require(g.state == State.Ended, "End first");
        require(plainBoard.length == g.boardSize, "Size mismatch");
        emit GameRevealed(gameId, plainBoard);
    }

    // ---------------- Views ----------------

    function getState(uint256 gameId) external view returns (State) {
        return games[gameId].state;
    }

    function getBoardSize(uint256 gameId) external view returns (uint8) {
        return games[gameId].boardSize;
    }

    function getOpenedCount(uint256 gameId) external view returns (uint32) {
        return games[gameId].openedCount;
    }

    function getCommit(uint256 gameId) external view returns (bytes32) {
        return games[gameId].commitHash;
    }

    function isOpened(uint256 gameId, uint8 index) external view returns (bool) {
        return (_openedMask[gameId] & (1 << index)) != 0;
    }
}
